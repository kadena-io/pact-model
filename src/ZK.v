Require Import
  Hask.Control.Monad
  Hask.Control.Monad.Trans.State
  Pact.Data.Either
  Pact.Data.IList
  Pact.Lib
  Pact.Ty
  Pact.Bltn
  Pact.Exp
  Pact.Value
  Pact.SemTy
  Pact.Lang
  Pact.Lang.CapabilityType
  Pact.Lang.Capability
  Pact.SemBltn.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Set Equations With UIP.

Generalizable All Variables.
Set Primitive Projections.

Import ListNotations.

(* The ZK theorem

   Given:

   - a type of ZK proofs
   - a ZK "circuit" built from some function 'f'
   - a known argument 'x'
   - an unknown argument 'w'
   - some result 'y'
   - and (possible) constraints on the above, necessary to build the circuit

   then a proof witness generated by this circuit implies a proof of the
   statement:

     ∃ w, f x w = y

   In cases where only 'x' and 'f' are known and 'y' is needed, this
   permits the removal of 'w' from the problem statement, since we only
   need the witness 'zk_circuit f x y' to know that '∃ w, f x w = y'.
*)
Theorem zk_theorem :
  ∃ (zk_proof : ∀ (a b c : Type) (f : a → b → c), Type)
    (zk_circuit : ∀ {a b c : Type} (f : a → b → c), a → c → zk_proof a b c f)
    (zk_public_constraint : Type → Prop)
    (zk_private_constraint : Type → Prop)
    (zk_result_constraint : Type → Prop)
    (zk_function_constraint : ∀ {a b c : Type}, (a → b → c) → Prop),
  ∀ {a b c : Type}
    (f : a → b → c)
    (x : a)
    (y : c),
    zk_public_constraint a →
    zk_private_constraint b →
    zk_result_constraint c →
    zk_function_constraint f →
    zk_proof a b c f → ∃ w : b, f x w = y.
