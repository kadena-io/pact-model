Require Import
  Coq.ZArith.ZArith
  Hask.Control.Monad
  Hask.Data.Either
  Hask.Data.Maybe
  Pact.ilist
  Pact.Lib
  Pact.Ty
  Pact.Exp
  Pact.Value
  Pact.Ren
  Pact.Sub
  Pact.Lang.CapabilityType.

From Equations Require Import Equations.
Set Equations With UIP.

Generalizable All Variables.

Section SemTy.

Import ListNotations.

Definition SemPrimTy (ty : PrimType) : Type :=
  match ty with
  | PrimUnit    => unit
  | PrimInteger => Z
  | PrimDecimal => N
  | PrimTime    => nat
  | PrimBool    => bool
  | PrimString  => string
  end.

Context `{Monad m}.

Fixpoint SemTy (œÑ : Ty) : Type :=
  match œÑ with
  | TyArrow dom cod => SemTy dom ‚Üí m (SemTy cod)

  | TyPrim p        => SemPrimTy p
  | TySym           => string

  | TyList t        => list (SemTy t)
  | TyPair t1 t2    => SemTy t1 * SemTy t2

  (* These types are used by capabilities. *)
  | TyCap p v       => Cap {| paramTy := reifyTy p; valueTy := reifyTy v |}
  end.

Notation "‚ü¶ t ‚üß" := (SemTy t) (at level 9) : type_scope.

Lemma reflectTy_reifyTy {œÑ} :
  ConcreteP œÑ ‚Üí reflectTy (reifyTy œÑ) = ‚ü¶œÑ‚üß.
Proof.
  induction œÑ; simpl in *; intros; auto.
  - inv H0.
  - now destruct p.
  - inv H0.
    f_equal.
    now apply IHœÑ.
  - inv H0.
    f_equal.
    + now apply IHœÑ1.
    + now apply IHœÑ2.
  - inv H0.
Qed.

Equations reify `(v : ‚ü¶ t ‚üß) (C : ConcreteP t) : Value t :=
  reify (t:=ùïå)     v PrimDecP := VUnit;
  reify (t:=‚Ñ§)     v PrimDecP := VInteger v;
  reify (t:=ùîª)     v PrimDecP := VDecimal v;
  reify (t:=ùïã)     v PrimDecP := VTime v;
  reify (t:=ùîπ)     v PrimDecP := VBool v;
  reify (t:=ùïä)     v PrimDecP := VString v;
  reify (t:=TySym) v SymDecP  := VSymbol v;

  reify (t:=TyList _) [] (ListDecP H) := VList [];
  reify (t:=TyList _) xs (ListDecP H) := VList (map (Œª x, reify x H) xs);

  reify (t:=TyPair _ _) (x, y) (PairDecP Hx Hy) :=
    VPair (reify x Hx) (reify y Hy).

Equations reflect `(v : Value t) : ‚ü¶ t ‚üß :=
  reflect (t:=TyPrim PrimUnit)    VUnit        := tt;
  reflect (t:=TyPrim PrimInteger) (VInteger v) := v;
  reflect (t:=TyPrim PrimDecimal) (VDecimal v) := v;
  reflect (t:=TyPrim PrimTime)    (VTime v)    := v;
  reflect (t:=TyPrim PrimBool)    (VBool v)    := v;
  reflect (t:=TyPrim PrimString)  (VString v)  := v;
  reflect (t:=TySym)              (VSymbol v)  := v;
  reflect (t:=TyList _)           (VList vs)   := map reflect vs;
  reflect (t:=TyPair _ _)         (VPair x y)  := (reflect x, reflect y).

#[export]
Program Instance SemPrimTy_EqDec {ty} : EqDec (SemPrimTy ty).
Next Obligation.
  induction ty; simpl in x, y.
  - destruct x, y.
    now left.
  - apply Z_EqDec.
  - apply N_EqDec.
  - apply nat_EqDec.
  - apply bool_EqDec.
  - apply string_EqDec.
Defined.

#[export]
Program Instance Concrete_EqDec {t} (H : ConcreteP t) : EqDec ‚ü¶t‚üß.
Next Obligation.
  induction H0;
  try first [ now inv H0 | now apply Value_EqDec ];
  simpl in x, y.
  - apply SemPrimTy_EqDec.
  - apply string_EqDec.
  - apply list_eqdec.
    fold SemTy.
    unfold EqDec.
    apply IHConcreteP.
  - destruct x, y.
    destruct (IHConcreteP1 s s1); subst.
    + destruct (IHConcreteP2 s0 s2); subst.
      * now left.
      * right; intro; now inv H0.
    + right; intro; now inv H0.
Defined.

End SemTy.

Arguments Token {s} name arg val.

Notation "‚ü¶ t ‚üß" := (SemTy t) (at level 9) : type_scope.
