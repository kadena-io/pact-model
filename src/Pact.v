Require Export
  Coq.ZArith.ZArith
  Ty
  Exp
  Sub
  Sem
  Eval
  Norm
  CEK.

From Equations Require Import Equations.
Set Equations With UIP.

Generalizable All Variables.

Section Pact.

Import ListNotations.

Open Scope Ty_scope.
Open Scope Z_scope.

Inductive Pact := PactLang.     (* this is just a type-level tag *)

Derive NoConfusion for Pact.

Inductive PactTy := TyInteger.

Derive NoConfusion for PactTy.

Definition Pact_HostTypes : HostTypes Pact := {|
  HostTy := PactTy;
  HostTySem := Œª ty,
    match ty with
    | TyInteger => Z
    end
|}.

Definition ‚Ñ§ := TyHost (H:=Pact_HostTypes) TyInteger.
Arguments ‚Ñ§ /.
(* Definition ‚Ñù := TyHost TyDecimal. *)
(* Definition ùïã := TyHost TyTime. *)
(* Definition ùïä := TyHost TyString. *)
Definition ùîπ := TyBool (H:=Pact_HostTypes).

Inductive PactExp : Ty (H:=Pact_HostTypes) ‚Üí Type :=
  | PInteger : Z ‚Üí PactExp ‚Ñ§
  | FAdd     : PactExp (‚Ñ§ √ó ‚Ñ§ ‚ü∂ ‚Ñ§).

Derive Signature NoConfusion Subterm for PactExp.

Definition Pact_HostExprs : HostExprs Pact := {|
  has_host_types := Pact_HostTypes;
  HostExp := PactExp
|}.

Equations Pact_HostExpSem `(e : PactExp œÑ) : SemTy (H:=Pact_HostTypes) œÑ :=
  Pact_HostExpSem (PInteger z) := z;
  Pact_HostExpSem FAdd         := Œª '(x, y), x + y.

Fail Equations PactF
          {Œì : Env (H:=Pact_HostExprs)}
          {dom cod : Ty (H:=Pact_HostTypes)}
          (e : PactExp (dom ‚ü∂ cod))
          (v : Exp (H:=Pact_HostExprs) Œì dom)
          (V : ValueP (H:=Pact_HostExprs) v) : Exp Œì cod :=
  PactF (dom:=?(‚Ñ§ √ó ‚Ñ§)) (cod:=?(‚Ñ§))
        FAdd (Pair (Hosted (PInteger x)) (Hosted (PInteger y))) :=
    Hosted (H:=Pact_HostExprs) (PInteger (x + y)).

Definition PactF {Œì} `(e : PactExp (dom ‚ü∂ cod))
           (v : Exp (H:=Pact_HostExprs) Œì dom) (V : ValueP v) : Exp Œì cod.
Proof.
  dependent destruction e.
  - inv V.
    inv X;  inv x0; rename H into x.
    inv X0; inv x0; rename H into y.
    exact (Hosted (H:=Pact_HostExprs) (PInteger (x + y))).
Defined.

Program Instance Pact_HostExprsSem : HostExprsSem Pact := {|
  has_host_exprs := Pact_HostExprs;
  HostExpSem := @Pact_HostExpSem;
  CallHost := @PactF;
  GetBool := Œª _ x, exist _ _ _;
  GetPair := Œª _ _ _ x, exist _ _ _;
|}.
Next Obligation. now inv X0. Defined.
Next Obligation. now inv x. Defined.
Next Obligation. now inv x. Defined.
Next Obligation. now inv x. Defined.
Next Obligation. now inv x. Defined.
Next Obligation. now inv x. Defined.
Next Obligation. now inv H. Defined.

Program Instance Pact_HostLang : HostLang Pact := {|
  has_host_exprs_sem := Pact_HostExprsSem;
|}.
Next Obligation.
  dependent destruction f; simp Pact_HostExpSem.
  dependent elimination H; reduce.
  dependent elimination v0; reduce.
  dependent elimination v1; reduce.
  dependent elimination x0; reduce.
  dependent elimination x; reduce.
  simpl; simp Pact_HostExpSem.
  pose proof Pact_HostExpSem_equation_2.
  now simpl in H; rewrite H.
Qed.
Next Obligation. Admitted.
Next Obligation. Admitted.
Next Obligation. Admitted.
Next Obligation. Admitted.
Next Obligation. Admitted.
Next Obligation. Admitted.
Next Obligation. Admitted.
Next Obligation. Admitted.
Next Obligation. Admitted.
Next Obligation. Admitted.
Next Obligation. Admitted.
Next Obligation. Admitted.
Next Obligation. Admitted.
Next Obligation. Admitted.
Next Obligation. Admitted.
Next Obligation. Admitted.

Definition num {Œì} (z : Z) : Exp Œì ‚Ñ§ := Hosted (PInteger z).
Arguments num {Œì} z /.

Example exp_constant :
  run 10 (num 123) =
    MkŒ£ (num 123) Empty MT.
Proof. reflexivity. Qed.

Example exp_pair :
  run 20 (Pair (num 123) (num 456)) =
    MkŒ£ (Pair (num 123) (num 456)) Empty MT.
Proof. reflexivity. Qed.

Example exp_lam œÑ :
  run 10 (LAM (cod:=œÑ) (VAR ZV)) =
    MkŒ£ (LAM (VAR ZV)) Empty MT.
Proof. reflexivity. Qed.

Example exp_app :
  run 10 (APP (LAM (VAR ZV)) (num 123)) =
    MkŒ£ (num 123) Empty MT.
Proof. reflexivity. Qed.

Example exp_call_FAdd :
  run 10 (APP (Hosted FAdd) (Pair (num 123) (num 456))) =
    MkŒ£ (num 579) Empty MT.
Proof. reflexivity. Qed.

End Pact.
